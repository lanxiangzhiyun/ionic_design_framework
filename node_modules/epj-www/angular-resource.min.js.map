{"version":3,"sources":["webpack:///angular-resource.min.js","webpack:///webpack/bootstrap da033aa87e206be0c7f0","webpack:///./angular-resource.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","window","angular","undefined","isValidDottedPath","path","MEMBER_NAME_REGEX","test","lookupDottedPath","obj","$resourceMinErr","keys","split","i","ii","length","key","shallowClearAndCopy","src","dst","forEach","value","hasOwnProperty","charAt","$$minErr","provider","this","defaults","stripTrailingSlashes","actions","get","method","save","query","isArray","remove","delete","$get","$http","$q","encodeUriSegment","val","encodeUriQuery","replace","pctEncodeSpaces","encodeURIComponent","Route","template","extend","urlParams","resourceFactory","url","paramDefaults","options","extractParams","data","actionParams","ids","isFunction","substr","defaultResponseInterceptor","response","resource","Resource","route","prototype","toJSON","$promise","$resolved","action","name","hasBody","a1","a2","a3","a4","success","error","params","arguments","isInstanceCall","httpConfig","responseInterceptor","interceptor","responseErrorInterceptor","responseError","copy","setUrlParams","promise","then","item","push","noop","reject","headers","result","bind","additionalParamDefaults","config","actionUrl","encodedVal","self","param","RegExp","_","urlParam","isDefined","match","p1","leadingSlashes","tail"],"mappings":"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","file":"angular-resource.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!*****************************!*\\\n  !*** ./angular-resource.js ***!\n  \\*****************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * @license AngularJS v1.4.3\n\t * (c) 2010-2015 Google, Inc. http://angularjs.org\n\t * License: MIT\n\t */\n\t(function(window, angular, undefined) {'use strict';\n\t\n\tvar $resourceMinErr = angular.$$minErr('$resource');\n\t\n\t// Helper functions and regex to lookup a dotted path on an object\n\t// stopping at undefined/null.  The path must be composed of ASCII\n\t// identifiers (just like $parse)\n\tvar MEMBER_NAME_REGEX = /^(\\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;\n\t\n\tfunction isValidDottedPath(path) {\n\t  return (path != null && path !== '' && path !== 'hasOwnProperty' &&\n\t      MEMBER_NAME_REGEX.test('.' + path));\n\t}\n\t\n\tfunction lookupDottedPath(obj, path) {\n\t  if (!isValidDottedPath(path)) {\n\t    throw $resourceMinErr('badmember', 'Dotted member path \"@{0}\" is invalid.', path);\n\t  }\n\t  var keys = path.split('.');\n\t  for (var i = 0, ii = keys.length; i < ii && obj !== undefined; i++) {\n\t    var key = keys[i];\n\t    obj = (obj !== null) ? obj[key] : undefined;\n\t  }\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Create a shallow copy of an object and clear other fields from the destination\n\t */\n\tfunction shallowClearAndCopy(src, dst) {\n\t  dst = dst || {};\n\t\n\t  angular.forEach(dst, function(value, key) {\n\t    delete dst[key];\n\t  });\n\t\n\t  for (var key in src) {\n\t    if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {\n\t      dst[key] = src[key];\n\t    }\n\t  }\n\t\n\t  return dst;\n\t}\n\t\n\t/**\n\t * @ngdoc module\n\t * @name ngResource\n\t * @description\n\t *\n\t * # ngResource\n\t *\n\t * The `ngResource` module provides interaction support with RESTful services\n\t * via the $resource service.\n\t *\n\t *\n\t * <div doc-module-components=\"ngResource\"></div>\n\t *\n\t * See {@link ngResource.$resource `$resource`} for usage.\n\t */\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $resource\n\t * @requires $http\n\t *\n\t * @description\n\t * A factory which creates a resource object that lets you interact with\n\t * [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.\n\t *\n\t * The returned resource object has action methods which provide high-level behaviors without\n\t * the need to interact with the low level {@link ng.$http $http} service.\n\t *\n\t * Requires the {@link ngResource `ngResource`} module to be installed.\n\t *\n\t * By default, trailing slashes will be stripped from the calculated URLs,\n\t * which can pose problems with server backends that do not expect that\n\t * behavior.  This can be disabled by configuring the `$resourceProvider` like\n\t * this:\n\t *\n\t * ```js\n\t     app.config(['$resourceProvider', function($resourceProvider) {\n\t       // Don't strip trailing slashes from calculated URLs\n\t       $resourceProvider.defaults.stripTrailingSlashes = false;\n\t     }]);\n\t * ```\n\t *\n\t * @param {string} url A parameterized URL template with parameters prefixed by `:` as in\n\t *   `/user/:username`. If you are using a URL with a port number (e.g.\n\t *   `http://example.com:8080/api`), it will be respected.\n\t *\n\t *   If you are using a url with a suffix, just add the suffix, like this:\n\t *   `$resource('http://example.com/resource.json')` or `$resource('http://example.com/:id.json')`\n\t *   or even `$resource('http://example.com/resource/:resource_id.:format')`\n\t *   If the parameter before the suffix is empty, :resource_id in this case, then the `/.` will be\n\t *   collapsed down to a single `.`.  If you need this sequence to appear and not collapse then you\n\t *   can escape it with `/\\.`.\n\t *\n\t * @param {Object=} paramDefaults Default values for `url` parameters. These can be overridden in\n\t *   `actions` methods. If any of the parameter value is a function, it will be executed every time\n\t *   when a param value needs to be obtained for a request (unless the param was overridden).\n\t *\n\t *   Each key value in the parameter object is first bound to url template if present and then any\n\t *   excess keys are appended to the url search query after the `?`.\n\t *\n\t *   Given a template `/path/:verb` and parameter `{verb:'greet', salutation:'Hello'}` results in\n\t *   URL `/path/greet?salutation=Hello`.\n\t *\n\t *   If the parameter value is prefixed with `@` then the value for that parameter will be extracted\n\t *   from the corresponding property on the `data` object (provided when calling an action method).  For\n\t *   example, if the `defaultParam` object is `{someParam: '@someProp'}` then the value of `someParam`\n\t *   will be `data.someProp`.\n\t *\n\t * @param {Object.<Object>=} actions Hash with declaration of custom actions that should extend\n\t *   the default set of resource actions. The declaration should be created in the format of {@link\n\t *   ng.$http#usage $http.config}:\n\t *\n\t *       {action1: {method:?, params:?, isArray:?, headers:?, ...},\n\t *        action2: {method:?, params:?, isArray:?, headers:?, ...},\n\t *        ...}\n\t *\n\t *   Where:\n\t *\n\t *   - **`action`** – {string} – The name of action. This name becomes the name of the method on\n\t *     your resource object.\n\t *   - **`method`** – {string} – Case insensitive HTTP method (e.g. `GET`, `POST`, `PUT`,\n\t *     `DELETE`, `JSONP`, etc).\n\t *   - **`params`** – {Object=} – Optional set of pre-bound parameters for this action. If any of\n\t *     the parameter value is a function, it will be executed every time when a param value needs to\n\t *     be obtained for a request (unless the param was overridden).\n\t *   - **`url`** – {string} – action specific `url` override. The url templating is supported just\n\t *     like for the resource-level urls.\n\t *   - **`isArray`** – {boolean=} – If true then the returned object for this action is an array,\n\t *     see `returns` section.\n\t *   - **`transformRequest`** –\n\t *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n\t *     transform function or an array of such functions. The transform function takes the http\n\t *     request body and headers and returns its transformed (typically serialized) version.\n\t *     By default, transformRequest will contain one function that checks if the request data is\n\t *     an object and serializes to using `angular.toJson`. To prevent this behavior, set\n\t *     `transformRequest` to an empty array: `transformRequest: []`\n\t *   - **`transformResponse`** –\n\t *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n\t *     transform function or an array of such functions. The transform function takes the http\n\t *     response body and headers and returns its transformed (typically deserialized) version.\n\t *     By default, transformResponse will contain one function that checks if the response looks like\n\t *     a JSON string and deserializes it using `angular.fromJson`. To prevent this behavior, set\n\t *     `transformResponse` to an empty array: `transformResponse: []`\n\t *   - **`cache`** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the\n\t *     GET request, otherwise if a cache instance built with\n\t *     {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\n\t *     caching.\n\t *   - **`timeout`** – `{number|Promise}` – timeout in milliseconds, or {@link ng.$q promise} that\n\t *     should abort the request when resolved.\n\t *   - **`withCredentials`** - `{boolean}` - whether to set the `withCredentials` flag on the\n\t *     XHR object. See\n\t *     [requests with credentials](https://developer.mozilla.org/en/http_access_control#section_5)\n\t *     for more information.\n\t *   - **`responseType`** - `{string}` - see\n\t *     [requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType).\n\t *   - **`interceptor`** - `{Object=}` - The interceptor object has two optional methods -\n\t *     `response` and `responseError`. Both `response` and `responseError` interceptors get called\n\t *     with `http response` object. See {@link ng.$http $http interceptors}.\n\t *\n\t * @param {Object} options Hash with custom settings that should extend the\n\t *   default `$resourceProvider` behavior.  The only supported option is\n\t *\n\t *   Where:\n\t *\n\t *   - **`stripTrailingSlashes`** – {boolean} – If true then the trailing\n\t *   slashes from any calculated URL will be stripped. (Defaults to true.)\n\t *\n\t * @returns {Object} A resource \"class\" object with methods for the default set of resource actions\n\t *   optionally extended with custom `actions`. The default set contains these actions:\n\t *   ```js\n\t *   { 'get':    {method:'GET'},\n\t *     'save':   {method:'POST'},\n\t *     'query':  {method:'GET', isArray:true},\n\t *     'remove': {method:'DELETE'},\n\t *     'delete': {method:'DELETE'} };\n\t *   ```\n\t *\n\t *   Calling these methods invoke an {@link ng.$http} with the specified http method,\n\t *   destination and parameters. When the data is returned from the server then the object is an\n\t *   instance of the resource class. The actions `save`, `remove` and `delete` are available on it\n\t *   as  methods with the `$` prefix. This allows you to easily perform CRUD operations (create,\n\t *   read, update, delete) on server-side data like this:\n\t *   ```js\n\t *   var User = $resource('/user/:userId', {userId:'@id'});\n\t *   var user = User.get({userId:123}, function() {\n\t *     user.abc = true;\n\t *     user.$save();\n\t *   });\n\t *   ```\n\t *\n\t *   It is important to realize that invoking a $resource object method immediately returns an\n\t *   empty reference (object or array depending on `isArray`). Once the data is returned from the\n\t *   server the existing reference is populated with the actual data. This is a useful trick since\n\t *   usually the resource is assigned to a model which is then rendered by the view. Having an empty\n\t *   object results in no rendering, once the data arrives from the server then the object is\n\t *   populated with the data and the view automatically re-renders itself showing the new data. This\n\t *   means that in most cases one never has to write a callback function for the action methods.\n\t *\n\t *   The action methods on the class object or instance object can be invoked with the following\n\t *   parameters:\n\t *\n\t *   - HTTP GET \"class\" actions: `Resource.action([parameters], [success], [error])`\n\t *   - non-GET \"class\" actions: `Resource.action([parameters], postData, [success], [error])`\n\t *   - non-GET instance actions:  `instance.$action([parameters], [success], [error])`\n\t *\n\t *\n\t *   Success callback is called with (value, responseHeaders) arguments, where the value is\n\t *   the populated resource instance or collection object. The error callback is called\n\t *   with (httpResponse) argument.\n\t *\n\t *   Class actions return empty instance (with additional properties below).\n\t *   Instance actions return promise of the action.\n\t *\n\t *   The Resource instances and collection have these additional properties:\n\t *\n\t *   - `$promise`: the {@link ng.$q promise} of the original server interaction that created this\n\t *     instance or collection.\n\t *\n\t *     On success, the promise is resolved with the same resource instance or collection object,\n\t *     updated with data from server. This makes it easy to use in\n\t *     {@link ngRoute.$routeProvider resolve section of $routeProvider.when()} to defer view\n\t *     rendering until the resource(s) are loaded.\n\t *\n\t *     On failure, the promise is resolved with the {@link ng.$http http response} object, without\n\t *     the `resource` property.\n\t *\n\t *     If an interceptor object was provided, the promise will instead be resolved with the value\n\t *     returned by the interceptor.\n\t *\n\t *   - `$resolved`: `true` after first server interaction is completed (either with success or\n\t *      rejection), `false` before that. Knowing if the Resource has been resolved is useful in\n\t *      data-binding.\n\t *\n\t * @example\n\t *\n\t * # Credit card resource\n\t *\n\t * ```js\n\t     // Define CreditCard class\n\t     var CreditCard = $resource('/user/:userId/card/:cardId',\n\t      {userId:123, cardId:'@id'}, {\n\t       charge: {method:'POST', params:{charge:true}}\n\t      });\n\t\n\t     // We can retrieve a collection from the server\n\t     var cards = CreditCard.query(function() {\n\t       // GET: /user/123/card\n\t       // server returns: [ {id:456, number:'1234', name:'Smith'} ];\n\t\n\t       var card = cards[0];\n\t       // each item is an instance of CreditCard\n\t       expect(card instanceof CreditCard).toEqual(true);\n\t       card.name = \"J. Smith\";\n\t       // non GET methods are mapped onto the instances\n\t       card.$save();\n\t       // POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}\n\t       // server returns: {id:456, number:'1234', name: 'J. Smith'};\n\t\n\t       // our custom method is mapped as well.\n\t       card.$charge({amount:9.99});\n\t       // POST: /user/123/card/456?amount=9.99&charge=true {id:456, number:'1234', name:'J. Smith'}\n\t     });\n\t\n\t     // we can create an instance as well\n\t     var newCard = new CreditCard({number:'0123'});\n\t     newCard.name = \"Mike Smith\";\n\t     newCard.$save();\n\t     // POST: /user/123/card {number:'0123', name:'Mike Smith'}\n\t     // server returns: {id:789, number:'0123', name: 'Mike Smith'};\n\t     expect(newCard.id).toEqual(789);\n\t * ```\n\t *\n\t * The object returned from this function execution is a resource \"class\" which has \"static\" method\n\t * for each action in the definition.\n\t *\n\t * Calling these methods invoke `$http` on the `url` template with the given `method`, `params` and\n\t * `headers`.\n\t * When the data is returned from the server then the object is an instance of the resource type and\n\t * all of the non-GET methods are available with `$` prefix. This allows you to easily support CRUD\n\t * operations (create, read, update, delete) on server-side data.\n\t\n\t   ```js\n\t     var User = $resource('/user/:userId', {userId:'@id'});\n\t     User.get({userId:123}, function(user) {\n\t       user.abc = true;\n\t       user.$save();\n\t     });\n\t   ```\n\t *\n\t * It's worth noting that the success callback for `get`, `query` and other methods gets passed\n\t * in the response that came from the server as well as $http header getter function, so one\n\t * could rewrite the above example and get access to http headers as:\n\t *\n\t   ```js\n\t     var User = $resource('/user/:userId', {userId:'@id'});\n\t     User.get({userId:123}, function(u, getResponseHeaders){\n\t       u.abc = true;\n\t       u.$save(function(u, putResponseHeaders) {\n\t         //u => saved user object\n\t         //putResponseHeaders => $http header getter\n\t       });\n\t     });\n\t   ```\n\t *\n\t * You can also access the raw `$http` promise via the `$promise` property on the object returned\n\t *\n\t   ```\n\t     var User = $resource('/user/:userId', {userId:'@id'});\n\t     User.get({userId:123})\n\t         .$promise.then(function(user) {\n\t           $scope.user = user;\n\t         });\n\t   ```\n\t\n\t * # Creating a custom 'PUT' request\n\t * In this example we create a custom method on our resource to make a PUT request\n\t * ```js\n\t *    var app = angular.module('app', ['ngResource', 'ngRoute']);\n\t *\n\t *    // Some APIs expect a PUT request in the format URL/object/ID\n\t *    // Here we are creating an 'update' method\n\t *    app.factory('Notes', ['$resource', function($resource) {\n\t *    return $resource('/notes/:id', null,\n\t *        {\n\t *            'update': { method:'PUT' }\n\t *        });\n\t *    }]);\n\t *\n\t *    // In our controller we get the ID from the URL using ngRoute and $routeParams\n\t *    // We pass in $routeParams and our Notes factory along with $scope\n\t *    app.controller('NotesCtrl', ['$scope', '$routeParams', 'Notes',\n\t                                      function($scope, $routeParams, Notes) {\n\t *    // First get a note object from the factory\n\t *    var note = Notes.get({ id:$routeParams.id });\n\t *    $id = note.id;\n\t *\n\t *    // Now call update passing in the ID first then the object you are updating\n\t *    Notes.update({ id:$id }, note);\n\t *\n\t *    // This will PUT /notes/ID with the note object in the request payload\n\t *    }]);\n\t * ```\n\t */\n\tangular.module('ngResource', ['ng']).\n\t  provider('$resource', function() {\n\t    var provider = this;\n\t\n\t    this.defaults = {\n\t      // Strip slashes by default\n\t      stripTrailingSlashes: true,\n\t\n\t      // Default actions configuration\n\t      actions: {\n\t        'get': {method: 'GET'},\n\t        'save': {method: 'POST'},\n\t        'query': {method: 'GET', isArray: true},\n\t        'remove': {method: 'DELETE'},\n\t        'delete': {method: 'DELETE'}\n\t      }\n\t    };\n\t\n\t    this.$get = ['$http', '$q', function($http, $q) {\n\t\n\t      var noop = angular.noop,\n\t        forEach = angular.forEach,\n\t        extend = angular.extend,\n\t        copy = angular.copy,\n\t        isFunction = angular.isFunction;\n\t\n\t      /**\n\t       * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n\t       * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set\n\t       * (pchar) allowed in path segments:\n\t       *    segment       = *pchar\n\t       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n\t       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n\t       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\t       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n\t       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\t       */\n\t      function encodeUriSegment(val) {\n\t        return encodeUriQuery(val, true).\n\t          replace(/%26/gi, '&').\n\t          replace(/%3D/gi, '=').\n\t          replace(/%2B/gi, '+');\n\t      }\n\t\n\t\n\t      /**\n\t       * This method is intended for encoding *key* or *value* parts of query component. We need a\n\t       * custom method because encodeURIComponent is too aggressive and encodes stuff that doesn't\n\t       * have to be encoded per http://tools.ietf.org/html/rfc3986:\n\t       *    query       = *( pchar / \"/\" / \"?\" )\n\t       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n\t       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\t       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n\t       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n\t       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\t       */\n\t      function encodeUriQuery(val, pctEncodeSpaces) {\n\t        return encodeURIComponent(val).\n\t          replace(/%40/gi, '@').\n\t          replace(/%3A/gi, ':').\n\t          replace(/%24/g, '$').\n\t          replace(/%2C/gi, ',').\n\t          replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n\t      }\n\t\n\t      function Route(template, defaults) {\n\t        this.template = template;\n\t        this.defaults = extend({}, provider.defaults, defaults);\n\t        this.urlParams = {};\n\t      }\n\t\n\t      Route.prototype = {\n\t        setUrlParams: function(config, params, actionUrl) {\n\t          var self = this,\n\t            url = actionUrl || self.template,\n\t            val,\n\t            encodedVal;\n\t\n\t          var urlParams = self.urlParams = {};\n\t          forEach(url.split(/\\W/), function(param) {\n\t            if (param === 'hasOwnProperty') {\n\t              throw $resourceMinErr('badname', \"hasOwnProperty is not a valid parameter name.\");\n\t            }\n\t            if (!(new RegExp(\"^\\\\d+$\").test(param)) && param &&\n\t              (new RegExp(\"(^|[^\\\\\\\\]):\" + param + \"(\\\\W|$)\").test(url))) {\n\t              urlParams[param] = true;\n\t            }\n\t          });\n\t          url = url.replace(/\\\\:/g, ':');\n\t\n\t          params = params || {};\n\t          forEach(self.urlParams, function(_, urlParam) {\n\t            val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];\n\t            if (angular.isDefined(val) && val !== null) {\n\t              encodedVal = encodeUriSegment(val);\n\t              url = url.replace(new RegExp(\":\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match, p1) {\n\t                return encodedVal + p1;\n\t              });\n\t            } else {\n\t              url = url.replace(new RegExp(\"(\\/?):\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match,\n\t                  leadingSlashes, tail) {\n\t                if (tail.charAt(0) == '/') {\n\t                  return tail;\n\t                } else {\n\t                  return leadingSlashes + tail;\n\t                }\n\t              });\n\t            }\n\t          });\n\t\n\t          // strip trailing slashes and set the url (unless this behavior is specifically disabled)\n\t          if (self.defaults.stripTrailingSlashes) {\n\t            url = url.replace(/\\/+$/, '') || '/';\n\t          }\n\t\n\t          // then replace collapse `/.` if found in the last URL path segment before the query\n\t          // E.g. `http://url.com/id./format?q=x` becomes `http://url.com/id.format?q=x`\n\t          url = url.replace(/\\/\\.(?=\\w+($|\\?))/, '.');\n\t          // replace escaped `/\\.` with `/.`\n\t          config.url = url.replace(/\\/\\\\\\./, '/.');\n\t\n\t\n\t          // set params - delegate param encoding to $http\n\t          forEach(params, function(value, key) {\n\t            if (!self.urlParams[key]) {\n\t              config.params = config.params || {};\n\t              config.params[key] = value;\n\t            }\n\t          });\n\t        }\n\t      };\n\t\n\t\n\t      function resourceFactory(url, paramDefaults, actions, options) {\n\t        var route = new Route(url, options);\n\t\n\t        actions = extend({}, provider.defaults.actions, actions);\n\t\n\t        function extractParams(data, actionParams) {\n\t          var ids = {};\n\t          actionParams = extend({}, paramDefaults, actionParams);\n\t          forEach(actionParams, function(value, key) {\n\t            if (isFunction(value)) { value = value(); }\n\t            ids[key] = value && value.charAt && value.charAt(0) == '@' ?\n\t              lookupDottedPath(data, value.substr(1)) : value;\n\t          });\n\t          return ids;\n\t        }\n\t\n\t        function defaultResponseInterceptor(response) {\n\t          return response.resource;\n\t        }\n\t\n\t        function Resource(value) {\n\t          shallowClearAndCopy(value || {}, this);\n\t        }\n\t\n\t        Resource.prototype.toJSON = function() {\n\t          var data = extend({}, this);\n\t          delete data.$promise;\n\t          delete data.$resolved;\n\t          return data;\n\t        };\n\t\n\t        forEach(actions, function(action, name) {\n\t          var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);\n\t\n\t          Resource[name] = function(a1, a2, a3, a4) {\n\t            var params = {}, data, success, error;\n\t\n\t            /* jshint -W086 */ /* (purposefully fall through case statements) */\n\t            switch (arguments.length) {\n\t              case 4:\n\t                error = a4;\n\t                success = a3;\n\t              //fallthrough\n\t              case 3:\n\t              case 2:\n\t                if (isFunction(a2)) {\n\t                  if (isFunction(a1)) {\n\t                    success = a1;\n\t                    error = a2;\n\t                    break;\n\t                  }\n\t\n\t                  success = a2;\n\t                  error = a3;\n\t                  //fallthrough\n\t                } else {\n\t                  params = a1;\n\t                  data = a2;\n\t                  success = a3;\n\t                  break;\n\t                }\n\t              case 1:\n\t                if (isFunction(a1)) success = a1;\n\t                else if (hasBody) data = a1;\n\t                else params = a1;\n\t                break;\n\t              case 0: break;\n\t              default:\n\t                throw $resourceMinErr('badargs',\n\t                  \"Expected up to 4 arguments [params, data, success, error], got {0} arguments\",\n\t                  arguments.length);\n\t            }\n\t            /* jshint +W086 */ /* (purposefully fall through case statements) */\n\t\n\t            var isInstanceCall = this instanceof Resource;\n\t            var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));\n\t            var httpConfig = {};\n\t            var responseInterceptor = action.interceptor && action.interceptor.response ||\n\t              defaultResponseInterceptor;\n\t            var responseErrorInterceptor = action.interceptor && action.interceptor.responseError ||\n\t              undefined;\n\t\n\t            forEach(action, function(value, key) {\n\t              if (key != 'params' && key != 'isArray' && key != 'interceptor') {\n\t                httpConfig[key] = copy(value);\n\t              }\n\t            });\n\t\n\t            if (hasBody) httpConfig.data = data;\n\t            route.setUrlParams(httpConfig,\n\t              extend({}, extractParams(data, action.params || {}), params),\n\t              action.url);\n\t\n\t            var promise = $http(httpConfig).then(function(response) {\n\t              var data = response.data,\n\t                promise = value.$promise;\n\t\n\t              if (data) {\n\t                // Need to convert action.isArray to boolean in case it is undefined\n\t                // jshint -W018\n\t                if (angular.isArray(data) !== (!!action.isArray)) {\n\t                  throw $resourceMinErr('badcfg',\n\t                      'Error in resource configuration for action `{0}`. Expected response to ' +\n\t                      'contain an {1} but got an {2} (Request: {3} {4})', name, action.isArray ? 'array' : 'object',\n\t                    angular.isArray(data) ? 'array' : 'object', httpConfig.method, httpConfig.url);\n\t                }\n\t                // jshint +W018\n\t                if (action.isArray) {\n\t                  value.length = 0;\n\t                  forEach(data, function(item) {\n\t                    if (typeof item === \"object\") {\n\t                      value.push(new Resource(item));\n\t                    } else {\n\t                      // Valid JSON values may be string literals, and these should not be converted\n\t                      // into objects. These items will not have access to the Resource prototype\n\t                      // methods, but unfortunately there\n\t                      value.push(item);\n\t                    }\n\t                  });\n\t                } else {\n\t                  shallowClearAndCopy(data, value);\n\t                  value.$promise = promise;\n\t                }\n\t              }\n\t\n\t              value.$resolved = true;\n\t\n\t              response.resource = value;\n\t\n\t              return response;\n\t            }, function(response) {\n\t              value.$resolved = true;\n\t\n\t              (error || noop)(response);\n\t\n\t              return $q.reject(response);\n\t            });\n\t\n\t            promise = promise.then(\n\t              function(response) {\n\t                var value = responseInterceptor(response);\n\t                (success || noop)(value, response.headers);\n\t                return value;\n\t              },\n\t              responseErrorInterceptor);\n\t\n\t            if (!isInstanceCall) {\n\t              // we are creating instance / collection\n\t              // - set the initial promise\n\t              // - return the instance / collection\n\t              value.$promise = promise;\n\t              value.$resolved = false;\n\t\n\t              return value;\n\t            }\n\t\n\t            // instance call\n\t            return promise;\n\t          };\n\t\n\t\n\t          Resource.prototype['$' + name] = function(params, success, error) {\n\t            if (isFunction(params)) {\n\t              error = success; success = params; params = {};\n\t            }\n\t            var result = Resource[name].call(this, params, this, success, error);\n\t            return result.$promise || result;\n\t          };\n\t        });\n\t\n\t        Resource.bind = function(additionalParamDefaults) {\n\t          return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);\n\t        };\n\t\n\t        return Resource;\n\t      }\n\t\n\t      return resourceFactory;\n\t    }];\n\t  });\n\t\n\t\n\t})(window, window.angular);\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** angular-resource.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap da033aa87e206be0c7f0\n **/","/**\n * @license AngularJS v1.4.3\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\nvar $resourceMinErr = angular.$$minErr('$resource');\n\n// Helper functions and regex to lookup a dotted path on an object\n// stopping at undefined/null.  The path must be composed of ASCII\n// identifiers (just like $parse)\nvar MEMBER_NAME_REGEX = /^(\\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;\n\nfunction isValidDottedPath(path) {\n  return (path != null && path !== '' && path !== 'hasOwnProperty' &&\n      MEMBER_NAME_REGEX.test('.' + path));\n}\n\nfunction lookupDottedPath(obj, path) {\n  if (!isValidDottedPath(path)) {\n    throw $resourceMinErr('badmember', 'Dotted member path \"@{0}\" is invalid.', path);\n  }\n  var keys = path.split('.');\n  for (var i = 0, ii = keys.length; i < ii && obj !== undefined; i++) {\n    var key = keys[i];\n    obj = (obj !== null) ? obj[key] : undefined;\n  }\n  return obj;\n}\n\n/**\n * Create a shallow copy of an object and clear other fields from the destination\n */\nfunction shallowClearAndCopy(src, dst) {\n  dst = dst || {};\n\n  angular.forEach(dst, function(value, key) {\n    delete dst[key];\n  });\n\n  for (var key in src) {\n    if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {\n      dst[key] = src[key];\n    }\n  }\n\n  return dst;\n}\n\n/**\n * @ngdoc module\n * @name ngResource\n * @description\n *\n * # ngResource\n *\n * The `ngResource` module provides interaction support with RESTful services\n * via the $resource service.\n *\n *\n * <div doc-module-components=\"ngResource\"></div>\n *\n * See {@link ngResource.$resource `$resource`} for usage.\n */\n\n/**\n * @ngdoc service\n * @name $resource\n * @requires $http\n *\n * @description\n * A factory which creates a resource object that lets you interact with\n * [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.\n *\n * The returned resource object has action methods which provide high-level behaviors without\n * the need to interact with the low level {@link ng.$http $http} service.\n *\n * Requires the {@link ngResource `ngResource`} module to be installed.\n *\n * By default, trailing slashes will be stripped from the calculated URLs,\n * which can pose problems with server backends that do not expect that\n * behavior.  This can be disabled by configuring the `$resourceProvider` like\n * this:\n *\n * ```js\n     app.config(['$resourceProvider', function($resourceProvider) {\n       // Don't strip trailing slashes from calculated URLs\n       $resourceProvider.defaults.stripTrailingSlashes = false;\n     }]);\n * ```\n *\n * @param {string} url A parameterized URL template with parameters prefixed by `:` as in\n *   `/user/:username`. If you are using a URL with a port number (e.g.\n *   `http://example.com:8080/api`), it will be respected.\n *\n *   If you are using a url with a suffix, just add the suffix, like this:\n *   `$resource('http://example.com/resource.json')` or `$resource('http://example.com/:id.json')`\n *   or even `$resource('http://example.com/resource/:resource_id.:format')`\n *   If the parameter before the suffix is empty, :resource_id in this case, then the `/.` will be\n *   collapsed down to a single `.`.  If you need this sequence to appear and not collapse then you\n *   can escape it with `/\\.`.\n *\n * @param {Object=} paramDefaults Default values for `url` parameters. These can be overridden in\n *   `actions` methods. If any of the parameter value is a function, it will be executed every time\n *   when a param value needs to be obtained for a request (unless the param was overridden).\n *\n *   Each key value in the parameter object is first bound to url template if present and then any\n *   excess keys are appended to the url search query after the `?`.\n *\n *   Given a template `/path/:verb` and parameter `{verb:'greet', salutation:'Hello'}` results in\n *   URL `/path/greet?salutation=Hello`.\n *\n *   If the parameter value is prefixed with `@` then the value for that parameter will be extracted\n *   from the corresponding property on the `data` object (provided when calling an action method).  For\n *   example, if the `defaultParam` object is `{someParam: '@someProp'}` then the value of `someParam`\n *   will be `data.someProp`.\n *\n * @param {Object.<Object>=} actions Hash with declaration of custom actions that should extend\n *   the default set of resource actions. The declaration should be created in the format of {@link\n *   ng.$http#usage $http.config}:\n *\n *       {action1: {method:?, params:?, isArray:?, headers:?, ...},\n *        action2: {method:?, params:?, isArray:?, headers:?, ...},\n *        ...}\n *\n *   Where:\n *\n *   - **`action`** – {string} – The name of action. This name becomes the name of the method on\n *     your resource object.\n *   - **`method`** – {string} – Case insensitive HTTP method (e.g. `GET`, `POST`, `PUT`,\n *     `DELETE`, `JSONP`, etc).\n *   - **`params`** – {Object=} – Optional set of pre-bound parameters for this action. If any of\n *     the parameter value is a function, it will be executed every time when a param value needs to\n *     be obtained for a request (unless the param was overridden).\n *   - **`url`** – {string} – action specific `url` override. The url templating is supported just\n *     like for the resource-level urls.\n *   - **`isArray`** – {boolean=} – If true then the returned object for this action is an array,\n *     see `returns` section.\n *   - **`transformRequest`** –\n *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n *     transform function or an array of such functions. The transform function takes the http\n *     request body and headers and returns its transformed (typically serialized) version.\n *     By default, transformRequest will contain one function that checks if the request data is\n *     an object and serializes to using `angular.toJson`. To prevent this behavior, set\n *     `transformRequest` to an empty array: `transformRequest: []`\n *   - **`transformResponse`** –\n *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n *     transform function or an array of such functions. The transform function takes the http\n *     response body and headers and returns its transformed (typically deserialized) version.\n *     By default, transformResponse will contain one function that checks if the response looks like\n *     a JSON string and deserializes it using `angular.fromJson`. To prevent this behavior, set\n *     `transformResponse` to an empty array: `transformResponse: []`\n *   - **`cache`** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the\n *     GET request, otherwise if a cache instance built with\n *     {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\n *     caching.\n *   - **`timeout`** – `{number|Promise}` – timeout in milliseconds, or {@link ng.$q promise} that\n *     should abort the request when resolved.\n *   - **`withCredentials`** - `{boolean}` - whether to set the `withCredentials` flag on the\n *     XHR object. See\n *     [requests with credentials](https://developer.mozilla.org/en/http_access_control#section_5)\n *     for more information.\n *   - **`responseType`** - `{string}` - see\n *     [requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType).\n *   - **`interceptor`** - `{Object=}` - The interceptor object has two optional methods -\n *     `response` and `responseError`. Both `response` and `responseError` interceptors get called\n *     with `http response` object. See {@link ng.$http $http interceptors}.\n *\n * @param {Object} options Hash with custom settings that should extend the\n *   default `$resourceProvider` behavior.  The only supported option is\n *\n *   Where:\n *\n *   - **`stripTrailingSlashes`** – {boolean} – If true then the trailing\n *   slashes from any calculated URL will be stripped. (Defaults to true.)\n *\n * @returns {Object} A resource \"class\" object with methods for the default set of resource actions\n *   optionally extended with custom `actions`. The default set contains these actions:\n *   ```js\n *   { 'get':    {method:'GET'},\n *     'save':   {method:'POST'},\n *     'query':  {method:'GET', isArray:true},\n *     'remove': {method:'DELETE'},\n *     'delete': {method:'DELETE'} };\n *   ```\n *\n *   Calling these methods invoke an {@link ng.$http} with the specified http method,\n *   destination and parameters. When the data is returned from the server then the object is an\n *   instance of the resource class. The actions `save`, `remove` and `delete` are available on it\n *   as  methods with the `$` prefix. This allows you to easily perform CRUD operations (create,\n *   read, update, delete) on server-side data like this:\n *   ```js\n *   var User = $resource('/user/:userId', {userId:'@id'});\n *   var user = User.get({userId:123}, function() {\n *     user.abc = true;\n *     user.$save();\n *   });\n *   ```\n *\n *   It is important to realize that invoking a $resource object method immediately returns an\n *   empty reference (object or array depending on `isArray`). Once the data is returned from the\n *   server the existing reference is populated with the actual data. This is a useful trick since\n *   usually the resource is assigned to a model which is then rendered by the view. Having an empty\n *   object results in no rendering, once the data arrives from the server then the object is\n *   populated with the data and the view automatically re-renders itself showing the new data. This\n *   means that in most cases one never has to write a callback function for the action methods.\n *\n *   The action methods on the class object or instance object can be invoked with the following\n *   parameters:\n *\n *   - HTTP GET \"class\" actions: `Resource.action([parameters], [success], [error])`\n *   - non-GET \"class\" actions: `Resource.action([parameters], postData, [success], [error])`\n *   - non-GET instance actions:  `instance.$action([parameters], [success], [error])`\n *\n *\n *   Success callback is called with (value, responseHeaders) arguments, where the value is\n *   the populated resource instance or collection object. The error callback is called\n *   with (httpResponse) argument.\n *\n *   Class actions return empty instance (with additional properties below).\n *   Instance actions return promise of the action.\n *\n *   The Resource instances and collection have these additional properties:\n *\n *   - `$promise`: the {@link ng.$q promise} of the original server interaction that created this\n *     instance or collection.\n *\n *     On success, the promise is resolved with the same resource instance or collection object,\n *     updated with data from server. This makes it easy to use in\n *     {@link ngRoute.$routeProvider resolve section of $routeProvider.when()} to defer view\n *     rendering until the resource(s) are loaded.\n *\n *     On failure, the promise is resolved with the {@link ng.$http http response} object, without\n *     the `resource` property.\n *\n *     If an interceptor object was provided, the promise will instead be resolved with the value\n *     returned by the interceptor.\n *\n *   - `$resolved`: `true` after first server interaction is completed (either with success or\n *      rejection), `false` before that. Knowing if the Resource has been resolved is useful in\n *      data-binding.\n *\n * @example\n *\n * # Credit card resource\n *\n * ```js\n     // Define CreditCard class\n     var CreditCard = $resource('/user/:userId/card/:cardId',\n      {userId:123, cardId:'@id'}, {\n       charge: {method:'POST', params:{charge:true}}\n      });\n\n     // We can retrieve a collection from the server\n     var cards = CreditCard.query(function() {\n       // GET: /user/123/card\n       // server returns: [ {id:456, number:'1234', name:'Smith'} ];\n\n       var card = cards[0];\n       // each item is an instance of CreditCard\n       expect(card instanceof CreditCard).toEqual(true);\n       card.name = \"J. Smith\";\n       // non GET methods are mapped onto the instances\n       card.$save();\n       // POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}\n       // server returns: {id:456, number:'1234', name: 'J. Smith'};\n\n       // our custom method is mapped as well.\n       card.$charge({amount:9.99});\n       // POST: /user/123/card/456?amount=9.99&charge=true {id:456, number:'1234', name:'J. Smith'}\n     });\n\n     // we can create an instance as well\n     var newCard = new CreditCard({number:'0123'});\n     newCard.name = \"Mike Smith\";\n     newCard.$save();\n     // POST: /user/123/card {number:'0123', name:'Mike Smith'}\n     // server returns: {id:789, number:'0123', name: 'Mike Smith'};\n     expect(newCard.id).toEqual(789);\n * ```\n *\n * The object returned from this function execution is a resource \"class\" which has \"static\" method\n * for each action in the definition.\n *\n * Calling these methods invoke `$http` on the `url` template with the given `method`, `params` and\n * `headers`.\n * When the data is returned from the server then the object is an instance of the resource type and\n * all of the non-GET methods are available with `$` prefix. This allows you to easily support CRUD\n * operations (create, read, update, delete) on server-side data.\n\n   ```js\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123}, function(user) {\n       user.abc = true;\n       user.$save();\n     });\n   ```\n *\n * It's worth noting that the success callback for `get`, `query` and other methods gets passed\n * in the response that came from the server as well as $http header getter function, so one\n * could rewrite the above example and get access to http headers as:\n *\n   ```js\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123}, function(u, getResponseHeaders){\n       u.abc = true;\n       u.$save(function(u, putResponseHeaders) {\n         //u => saved user object\n         //putResponseHeaders => $http header getter\n       });\n     });\n   ```\n *\n * You can also access the raw `$http` promise via the `$promise` property on the object returned\n *\n   ```\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123})\n         .$promise.then(function(user) {\n           $scope.user = user;\n         });\n   ```\n\n * # Creating a custom 'PUT' request\n * In this example we create a custom method on our resource to make a PUT request\n * ```js\n *    var app = angular.module('app', ['ngResource', 'ngRoute']);\n *\n *    // Some APIs expect a PUT request in the format URL/object/ID\n *    // Here we are creating an 'update' method\n *    app.factory('Notes', ['$resource', function($resource) {\n *    return $resource('/notes/:id', null,\n *        {\n *            'update': { method:'PUT' }\n *        });\n *    }]);\n *\n *    // In our controller we get the ID from the URL using ngRoute and $routeParams\n *    // We pass in $routeParams and our Notes factory along with $scope\n *    app.controller('NotesCtrl', ['$scope', '$routeParams', 'Notes',\n                                      function($scope, $routeParams, Notes) {\n *    // First get a note object from the factory\n *    var note = Notes.get({ id:$routeParams.id });\n *    $id = note.id;\n *\n *    // Now call update passing in the ID first then the object you are updating\n *    Notes.update({ id:$id }, note);\n *\n *    // This will PUT /notes/ID with the note object in the request payload\n *    }]);\n * ```\n */\nangular.module('ngResource', ['ng']).\n  provider('$resource', function() {\n    var provider = this;\n\n    this.defaults = {\n      // Strip slashes by default\n      stripTrailingSlashes: true,\n\n      // Default actions configuration\n      actions: {\n        'get': {method: 'GET'},\n        'save': {method: 'POST'},\n        'query': {method: 'GET', isArray: true},\n        'remove': {method: 'DELETE'},\n        'delete': {method: 'DELETE'}\n      }\n    };\n\n    this.$get = ['$http', '$q', function($http, $q) {\n\n      var noop = angular.noop,\n        forEach = angular.forEach,\n        extend = angular.extend,\n        copy = angular.copy,\n        isFunction = angular.isFunction;\n\n      /**\n       * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n       * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set\n       * (pchar) allowed in path segments:\n       *    segment       = *pchar\n       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n       */\n      function encodeUriSegment(val) {\n        return encodeUriQuery(val, true).\n          replace(/%26/gi, '&').\n          replace(/%3D/gi, '=').\n          replace(/%2B/gi, '+');\n      }\n\n\n      /**\n       * This method is intended for encoding *key* or *value* parts of query component. We need a\n       * custom method because encodeURIComponent is too aggressive and encodes stuff that doesn't\n       * have to be encoded per http://tools.ietf.org/html/rfc3986:\n       *    query       = *( pchar / \"/\" / \"?\" )\n       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n       */\n      function encodeUriQuery(val, pctEncodeSpaces) {\n        return encodeURIComponent(val).\n          replace(/%40/gi, '@').\n          replace(/%3A/gi, ':').\n          replace(/%24/g, '$').\n          replace(/%2C/gi, ',').\n          replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n      }\n\n      function Route(template, defaults) {\n        this.template = template;\n        this.defaults = extend({}, provider.defaults, defaults);\n        this.urlParams = {};\n      }\n\n      Route.prototype = {\n        setUrlParams: function(config, params, actionUrl) {\n          var self = this,\n            url = actionUrl || self.template,\n            val,\n            encodedVal;\n\n          var urlParams = self.urlParams = {};\n          forEach(url.split(/\\W/), function(param) {\n            if (param === 'hasOwnProperty') {\n              throw $resourceMinErr('badname', \"hasOwnProperty is not a valid parameter name.\");\n            }\n            if (!(new RegExp(\"^\\\\d+$\").test(param)) && param &&\n              (new RegExp(\"(^|[^\\\\\\\\]):\" + param + \"(\\\\W|$)\").test(url))) {\n              urlParams[param] = true;\n            }\n          });\n          url = url.replace(/\\\\:/g, ':');\n\n          params = params || {};\n          forEach(self.urlParams, function(_, urlParam) {\n            val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];\n            if (angular.isDefined(val) && val !== null) {\n              encodedVal = encodeUriSegment(val);\n              url = url.replace(new RegExp(\":\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match, p1) {\n                return encodedVal + p1;\n              });\n            } else {\n              url = url.replace(new RegExp(\"(\\/?):\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match,\n                  leadingSlashes, tail) {\n                if (tail.charAt(0) == '/') {\n                  return tail;\n                } else {\n                  return leadingSlashes + tail;\n                }\n              });\n            }\n          });\n\n          // strip trailing slashes and set the url (unless this behavior is specifically disabled)\n          if (self.defaults.stripTrailingSlashes) {\n            url = url.replace(/\\/+$/, '') || '/';\n          }\n\n          // then replace collapse `/.` if found in the last URL path segment before the query\n          // E.g. `http://url.com/id./format?q=x` becomes `http://url.com/id.format?q=x`\n          url = url.replace(/\\/\\.(?=\\w+($|\\?))/, '.');\n          // replace escaped `/\\.` with `/.`\n          config.url = url.replace(/\\/\\\\\\./, '/.');\n\n\n          // set params - delegate param encoding to $http\n          forEach(params, function(value, key) {\n            if (!self.urlParams[key]) {\n              config.params = config.params || {};\n              config.params[key] = value;\n            }\n          });\n        }\n      };\n\n\n      function resourceFactory(url, paramDefaults, actions, options) {\n        var route = new Route(url, options);\n\n        actions = extend({}, provider.defaults.actions, actions);\n\n        function extractParams(data, actionParams) {\n          var ids = {};\n          actionParams = extend({}, paramDefaults, actionParams);\n          forEach(actionParams, function(value, key) {\n            if (isFunction(value)) { value = value(); }\n            ids[key] = value && value.charAt && value.charAt(0) == '@' ?\n              lookupDottedPath(data, value.substr(1)) : value;\n          });\n          return ids;\n        }\n\n        function defaultResponseInterceptor(response) {\n          return response.resource;\n        }\n\n        function Resource(value) {\n          shallowClearAndCopy(value || {}, this);\n        }\n\n        Resource.prototype.toJSON = function() {\n          var data = extend({}, this);\n          delete data.$promise;\n          delete data.$resolved;\n          return data;\n        };\n\n        forEach(actions, function(action, name) {\n          var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);\n\n          Resource[name] = function(a1, a2, a3, a4) {\n            var params = {}, data, success, error;\n\n            /* jshint -W086 */ /* (purposefully fall through case statements) */\n            switch (arguments.length) {\n              case 4:\n                error = a4;\n                success = a3;\n              //fallthrough\n              case 3:\n              case 2:\n                if (isFunction(a2)) {\n                  if (isFunction(a1)) {\n                    success = a1;\n                    error = a2;\n                    break;\n                  }\n\n                  success = a2;\n                  error = a3;\n                  //fallthrough\n                } else {\n                  params = a1;\n                  data = a2;\n                  success = a3;\n                  break;\n                }\n              case 1:\n                if (isFunction(a1)) success = a1;\n                else if (hasBody) data = a1;\n                else params = a1;\n                break;\n              case 0: break;\n              default:\n                throw $resourceMinErr('badargs',\n                  \"Expected up to 4 arguments [params, data, success, error], got {0} arguments\",\n                  arguments.length);\n            }\n            /* jshint +W086 */ /* (purposefully fall through case statements) */\n\n            var isInstanceCall = this instanceof Resource;\n            var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));\n            var httpConfig = {};\n            var responseInterceptor = action.interceptor && action.interceptor.response ||\n              defaultResponseInterceptor;\n            var responseErrorInterceptor = action.interceptor && action.interceptor.responseError ||\n              undefined;\n\n            forEach(action, function(value, key) {\n              if (key != 'params' && key != 'isArray' && key != 'interceptor') {\n                httpConfig[key] = copy(value);\n              }\n            });\n\n            if (hasBody) httpConfig.data = data;\n            route.setUrlParams(httpConfig,\n              extend({}, extractParams(data, action.params || {}), params),\n              action.url);\n\n            var promise = $http(httpConfig).then(function(response) {\n              var data = response.data,\n                promise = value.$promise;\n\n              if (data) {\n                // Need to convert action.isArray to boolean in case it is undefined\n                // jshint -W018\n                if (angular.isArray(data) !== (!!action.isArray)) {\n                  throw $resourceMinErr('badcfg',\n                      'Error in resource configuration for action `{0}`. Expected response to ' +\n                      'contain an {1} but got an {2} (Request: {3} {4})', name, action.isArray ? 'array' : 'object',\n                    angular.isArray(data) ? 'array' : 'object', httpConfig.method, httpConfig.url);\n                }\n                // jshint +W018\n                if (action.isArray) {\n                  value.length = 0;\n                  forEach(data, function(item) {\n                    if (typeof item === \"object\") {\n                      value.push(new Resource(item));\n                    } else {\n                      // Valid JSON values may be string literals, and these should not be converted\n                      // into objects. These items will not have access to the Resource prototype\n                      // methods, but unfortunately there\n                      value.push(item);\n                    }\n                  });\n                } else {\n                  shallowClearAndCopy(data, value);\n                  value.$promise = promise;\n                }\n              }\n\n              value.$resolved = true;\n\n              response.resource = value;\n\n              return response;\n            }, function(response) {\n              value.$resolved = true;\n\n              (error || noop)(response);\n\n              return $q.reject(response);\n            });\n\n            promise = promise.then(\n              function(response) {\n                var value = responseInterceptor(response);\n                (success || noop)(value, response.headers);\n                return value;\n              },\n              responseErrorInterceptor);\n\n            if (!isInstanceCall) {\n              // we are creating instance / collection\n              // - set the initial promise\n              // - return the instance / collection\n              value.$promise = promise;\n              value.$resolved = false;\n\n              return value;\n            }\n\n            // instance call\n            return promise;\n          };\n\n\n          Resource.prototype['$' + name] = function(params, success, error) {\n            if (isFunction(params)) {\n              error = success; success = params; params = {};\n            }\n            var result = Resource[name].call(this, params, this, success, error);\n            return result.$promise || result;\n          };\n        });\n\n        Resource.bind = function(additionalParamDefaults) {\n          return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);\n        };\n\n        return Resource;\n      }\n\n      return resourceFactory;\n    }];\n  });\n\n\n})(window, window.angular);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./angular-resource.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}